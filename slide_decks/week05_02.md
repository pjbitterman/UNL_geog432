---
marp: true
size: 16:9 
paginate: true
#footer: Week 05.02
---


# GEOG 432/832: Programming, Scripting, and Automation for GIS

#

## Unit 05.02: Listing data and cursors

### Dr. Bitterman

#

--- 

# Today's schedule

- Open discussion
- Discussion and exercises
- For next class

---

# Open discussion

---


LISTING DATA

Batch processing, executing a single tool multiple times using different parameters, is one of the primary reasons for developing geoprocessing scripts. In chapter 3, you saw several ways to use batch processing, including the option to run tools in batch mode. However, there are limitations on using batch mode, and scripting provides a more powerful and flexible framework for batch processing.
One of the key tasks in batch processing is to make an inventory of the available data so a script can iterate over the data during processing. ArcPy includes several functions to inventory data. These functions return a list, which consists of a list of items. A list can contain any type of data, but strings are the most common type when working with ArcPy’s list functions.
The principle behind using a list is that a script can loop through the values in the list to work with each one individually. Working with a list in Python typically requires a for loop. The ArcPy list functions include ListFields(), ListIndexes(), ListDatasets(), ListFeatureClasses(), ListFiles(), ListRasters(), ListTables(), ListWorkspaces(), and ListVersions().
The parameters of these functions are similar. Some functions require an input dataset because the items of interest are located within a dataset or object. Other functions do not require a dataset because the items of interest are located within the current workspace. A workspace is required because you cannot pass a path to these functions. All functions have a wildcard parameter (*), which defines a name filter. A wildcard is a symbol that represents one or more characters. In the context of the ArcPy list functions, the wildcard is used to list only the elements that meet a specific criterion based on their name.
One of the most widely used list functions is the arcpy.ListFeatureClasses() function, which returns a list of feature classes in the current workspace. The syntax of the function is as follows:
arcpy.ListFeatureClasses({wild_card}, {feature_type}, 
                         {feature_dataset})
This function has three parameters, all of which are optional. These parameters make it possible to limit the list by name, feature type, or feature dataset. For example, the following code returns a list of all feature classes in the current workspace, without setting any of the optional parameters:
import arcpy
arcpy.env.workspace = "C:/Data"
fclist = arcpy.ListFeatureClasses()
All the list functions return a list. To confirm the contents of a list, you can print the values using a statement such as the following:
print(fclist)
A printed list of feature classes follows:
['floodzone.shp', 'roads.shp', 'streams.shp', 'wetlands.shp', 'zipcodes.shp']
A Python list of elements is surrounded by brackets [ ], and the elements are separated by commas. In the case of a list of feature classes, the elements are strings representing the names of feature classes.
The wildcard limits the list by name. For example, the following code creates a list of all feature classes in the current workspace that start with the letter w:
fclist = arcpy.ListFeatureClasses("w*")
The second parameter in the ListFeatureClasses() function is the feature type. This parameter restricts the list to match certain data properties, such as point feature classes only. For example, the following code creates a list of all the point feature classes in the current workspace:
fclist = arcpy.ListFeatureClasses("", "point")
Notice the use of an empty string ("") for the wildcard. Parameters must be entered in the order defined by the syntax and cannot be skipped unless you specifically refer to them by name. Using "*" provides the same result for this parameter as an empty string. Valid feature types include annotation, arc, dimension, edge, junction, label, line, multipatch, node, point, polygon, polyline, region, route, and tic. Several of these feature types represent legacy types associated with coverages, which are no longer supported in ArcGIS Pro.
Note: Although Python is case sensitive in general, arguments in ArcPy are more forgiving. For example, for the second parameter, you could use "POINT" or "Point" instead of "point". However, ArcPy's functions and classes must be called using the correct capital letters per the documentation. For example, ListFeatureclasses() results in an AttributeError because the function cannot be found.
To create a list of raster datasets in the current workspace, use the arcpy.ListRasters() function. The syntax is close to that of the ListFeatureClasses() function:
arcpy.ListRasters({wild_card}, {raster_type})
The two parameters are optional and allow you to restrict the list by name or type. The following code creates a list of all raster datasets in the current workspace:
import arcpy
arcpy.env.workspace = "C:/Data"
rasterlist = arcpy.ListRasters()
To restrict the list to all rasters that are TIFF images, specify the raster type parameter as follows:
rasterlist = arcpy.ListRasters("", "TIF")
The raster type parameter should be specified as the file extension, not the generic name of the format. For example, a TIFF file has the file extension .tif, so “TIF” is the correct syntax. Similarly, a JPEG file has the file extension .jpg, so “JPG” is the correct syntax. The syntax for raster data types is not case sensitive, so both “TIF” and “tif” are correct. Also note that the Esri GRID format does not have a file extension, and the proper syntax for this format is “GRID” (also not case sensitive). Valid raster data types consist of BMP, GIF, IMG, JP2, JPG, PNG, TIF, and GRID.
Another commonly used list function is arcpy.ListFields(). This function lists the fields in a feature class or table for a specified dataset. The syntax is
arcpy.ListFields(dataset, {wild_card}, {field_type})
The ListFields() function has three parameters, of which only the first one (dataset) is required. The dataset is the feature class or table whose fields will be returned as values in a list. For example, the following code creates a list of all the fields in a shapefile:
import arcpy
arcpy.env.workspace = "C:/Data"
fieldlist = arcpy.ListFields("roads.shp")
The two optional parameters allow you to restrict the list by name or field type. The following code creates a list of all the fields in a shapefile that are integers:
fieldlist = arcpy.ListFields("roads.shp", "", "Integer")
Valid field types include BLOB (binary large object), Date, Double, Geometry, GlobalID, GUID, Integer, OID, Raster, Single, SmallInteger, and String. Field types are written as strings and are not case sensitive.
Note that the names of the field types used by the ListFields() function are not identical to those used in the ArcGIS Pro application. The type Integer is referred to as Long; Single is referred to as Float; SmallInteger is referred to as Short; and String is referred to as Text. This naming can be a source of confusion because the arcpy.AddField() function is consistent with the terminology of the ArcGIS Pro application. When adding a field using the AddField() function, the previous field types are referred to as LONG, FLOAT, SHORT, and TEXT, respectively.
The ListFields() function returns a list of Field objects. By contrast, most of the other list functions return a list of strings. A Field object represents a column in a table. Field object properties include the name, alias, type, and length. The next section includes an example of using these properties. Note that the type property uses the same field types as the ListFields() function—i.e., a long integer is referred to as an Integer and so on.
Another useful list function is arcpy.ListFiles(). This function returns a list of all the files in a workspace. The general syntax of the ListFiles() function is
arcpy.ListFiles({wild_card})
The only parameter is an optional wildcard to limit the results. The ListFiles() function is similar to opening the folder of interest in a file manager application such as Windows Explorer. This is slightly different from viewing files in the Catalog pane in ArcGIS Pro. Consider the following example of the Catalog view of a folder called Greenway.

he folder C:\Greenway contains various subfolders, as well as a file geodatabase (.gdb), a Microsoft Excel file (.xlsx), a toolbox file (.tbx), a shapefile (.shp), and several CSV files (.csv). The code to use the ListFiles() function on this folder is as follows:
import arcpy
arcpy.env.workspace = "C:/Testing/Demo/Greenway"
for file in arcpy.ListFiles():
    print(file)
The result prints as follows:
datasheet1.csv
datasheet2.csv
datasheet3.csv
Greenway.aprx
Greenway.gdb
Greenway.tbx
ImportLog
Index
parks.dbf
parks.prj
parks.sbn
parks.sbx
parks.shp
parks.shp.xml
parks.shx
Project
Report.docx
survey_results.xlsx
The results illustrate a few things about the ListFiles() function. First, subfolders are shown, but the contents inside those folders are not. For example, the shapefiles inside the Project folder are not on the list. Second, file geodatabases are included, but their contents are not. For example, the feature classes inside the Greenway.gdb file are not on the list. Third, individual shapefiles consist of multiple files with the same base name and different file extensions. The ListFiles() function lists all those files separately, which consist of only a single shapefile entry in the Catalog view. And finally, some files are not shown in the Catalog view in ArcGIS Pro, but they are listed. These files include the Microsoft Word document called Report.docx.
These results indicate that the ListFiles() function takes a file management perspective and does not consider the nature of the underlying data. When working with spatial data formats, such as shapefiles and geodatabases, it is therefore recommended to use other ArcPy list functions, including ListFeatureClasses(), ListWorkspaces(), ListDatasets(), and so on.
The ListFiles() function commonly is used to list stand-alone files that are not spatial data­sets, including CSV files (.csv), Microsoft Excel files (.xlsx), and plain text files (.txt). For example, the following example code creates a list of only the CSV files in a workspace:
import arcpy
arcpy.env.workspace = "C:/Testing/Demo/Greenway"
for file in arcpy.ListFiles("*.csv"):
    print(file)
The result prints as follows:
datasheet1.csv
datasheet2.csv
datasheet3.csv
Instead of printing the file names, in a typical GIS workflow the list of CSV files is used to do something more meaningful, such as copying the data from each CSV file to a geodatabase table or using the data in each CSV file to create new features. Chapter 8 revisits these examples.



GIVE A WALK example


LISTS IN FOR LOOPS

How have we done this before?
Once you have a list of desired values, you can use the list for batch processing of multiple datasets. This processing is most commonly accomplished using a for loop. A for loop iterates over the list, one element at a time; when there are no values left to be iterated, the loop is finished. The earlier example of the use of da.Walk() already illustrates an example of using a for loop. Although this function returns a tuple, the iteration over the elements using a for loop is identical to working with lists. This section takes a closer look at iteration using for loops.
For example, consider using a for loop with raster data. The code is as follows:
import arcpy
arcpy.env.workspace = "C:/Data"
tifflist = arcpy.ListRasters("", "TIF")
for tiff in tifflist:
    arcpy.BuildPyramids_management(tiff)
In this example, the ListRasters() function is used to create a list of TIFF files. The for loop iterates over each element in the list and builds pyramids for each raster. This code becomes quite powerful because it can automate rather tedious tasks. For example, building pyramids for hundreds of rasters could become time-consuming. The few lines of Python code used here are enough to carry out this task, and the code is the same whether there are only a few raster datasets or several hundred.
As another example, iteration using a for loop used in combination with the ListFields() function provides a detailed description of the fields and their properties. The following code creates a list of fields in a single shapefile, and then prints the name, type, and length of each field:
import arcpy
arcpy.env.workspace = "C:/Data"
fieldlist = arcpy.ListFields("roads.shp")
for field in fieldlist:
    print("{0} is a field of type {1} with a length of {2}".
          format(field.name, field.type, field.length))
Python lists often are used to automate repetitive tasks. Consider a scenario in which the original data consists of several shapefiles in a single folder. Your task is to read all the shapefiles and copy them into an existing geodatabase. Here is the code for this task:
import arcpy
import os
arcpy.env.workspace = "C:/Transportation"
outgdb = "C:/Transportation/City.gdb"
fcs = arcpy.ListFeatureClasses()
for fc in fcs:
    desc = arcpy.da.Describe(fc)
    outfc = os.path.join(outgdb, desc["baseName"])
    arcpy.CopyFeatures_management(fc, outfc)
A few observations are in order. A shapefile has a file extension .shp. To remove this file extension, the da.Describe() function obtains the baseName property of the shapefile. For example, for a shapefile named rivers.shp, the baseName property is rivers, and that is used as the name for the output feature class. The Copy Features tool, however, requires the full path—i.e., C:\Transportation\City.gdb\rivers. This full path can be obtained using os.path.join().
A somewhat different approach is needed when subfolders are present. Consider the following file structure of a folder called City with subfolders containing shapefiles and a folder called City_Copy with a geodatabase, as shown in the figure.
Catalog view of a folder called City.
Description
Your task is to copy all the shapefiles into an existing geodatabase. The shapefiles reside in different folders. This folder structure complicates the use of the ListFeatureClasses() function because each folder is a separate workspace. The da.Walk() function is an alternative and more efficient way to locate all the shapefiles and copy them. Here is the code for this task:
import arcpy
import os
workspace = "C:/City"
outgdb = "C:/City_Copy/Study.gdb"
walk = arcpy.da.Walk(workspace, datatype="FeatureClass")
for dirpath, dirnames, filenames in walk:
    for file in filenames:
        infc = os.path.join(dirpath, file)
        desc = arcpy.da.Describe(infc)
        outfc = os.path.join(outgdb, desc["baseName"])
        arcpy.CopyFeatures_management(infc, outfc)
The code differs from the previous solution in several ways. First, env.workspace is not used because the workspace is set explicitly in the da.Walk() function. Second, the file names returned by the da.Walk() function do not include the full path, and as a result the path for the input feature classes must be created using os.path.join().
The result of the script is a copy of all the shapefiles in the target geodatabase, as shown in the figure.
Catalog view of a geodatabase called Study.gdb with six feature classes.
Note: The target geodatabase must be in a folder that is separate from the workspace used by the arcpy .da.Walk() function.
Later chapters utilize for loops for many other workflow scenarios.


IN-CLASS EXERCISE

- Clip all features IN A GEODATABASE TO LANCASTER COUNTY BuT NOT LANCASTER COUNTY ITSELF
- Appened "_lc" to the end


READING RECORDS

3.2.2 Reading through records
PrintPrint
Now that you know how to traverse the table horizontally, reading the fields that are available, let's examine how to read up and down through the table records.

The arcpy module contains some objects called cursors that allow you to move through records in a table. There have been quite a few changes made to how cursors can be used over the different versions of ArcGIS, though the current best practice has been in place since version 10.1 of ArcGIS Desktop (aka ArcMap) and has carried over to ArcGIS Pro.  If you find yourself working with code that was written for a pre-10.1 version of ArcMap, we suggest you check out this same page in our old ArcMap version of this course (see the content navigation links on the right side of the Drupal site).  We will focus our discussion below on the current best practice in cursor usage, which you should be utilizing for scripts written in this course and in your workplace.  

The arcpy data access module
At version 10.1 of ArcMap, Esri released a new data access module, which offered faster performance along with more robust behavior when crashes or errors were encountered with the cursor.  The module contains different cursor classes for the different operations a developer might want to perform on table records -- one for selecting, or reading, existing records; one for making changes to existing records; and one for adding new records.  We'll discuss the editing cursors later, focusing our discussion now on the cursor used for reading tabular data, the search cursor. 

As with all geoprocessing classes, the SearchCursor class is documented in the Help system.  (Be sure when searching the Help system that you choose the SearchCursor class found in the Data Access module.  An older, pre-10.1 class is available through the arcpy module and appears in the Help system as an "ArcPy Function.")  

The common workflow for reading data with a search cursor is as follows:

Create the search cursor. This is done through the method arcpy.da.SearchCursor(). This method takes several parameters in which you specify which dataset and, optionally, which specific rows you want to read.
Set up a loop that will iterate through the rows until there are no more available to read.
Within the loop, do something with the values in the current row.
Here's a very simple example of a search cursor that reads through a point dataset of cities and prints the name of each.

?
1
2
3
4
5
6
7
8
9
# Prints the name of each city in a feature class
 
import arcpy
 
featureClass = "C:\\Data\\USA\\USA.gdb\\Cities"
 
with arcpy.da.SearchCursor(featureClass,("NAME")) as cursor:
    for row in cursor:
        print (row[0])
Important points to note in this example:

The cursor is created using a "with" statement. Although the explanation of "with" is somewhat technical, the key thing to understand is that it allows your cursor to exit the dataset gracefully, whether it crashes or completes its work successfully. This is a big issue with cursors, which can sometimes maintain locks on data if they are not exited properly.
The "with" statement requires that you indent all the code beneath it. After you create the cursor in your "with" statement, you'll initiate a for loop to run through all the rows in the table. This requires additional indentation.
Creating a SearchCursor object requires specifying not just the desired table/feature class, but also the desired fields within it, as a tuple.  Remember that a tuple is a Python data structure much like a list, except it is enclosed in parentheses and its contents cannot be modified.  Supplying this tuple speeds up the work of the cursor because it does not have to deal with the potentially dozens of fields included in your dataset. In the example above, the tuple contains just one field, "NAME".
The "with" statement creates a SearchCursor object, and declares that it will be named "cursor" in any subsequent code. 
A for loop is used to iterate through the SearchCursor (using the "cursor" name assigned to it).  Just as in a loop through a list, the iterator variable can be assigned a name of your choice (here, it's called "row").
Retrieving values out of the rows is done using the index position of the field name in the tuple you submitted when you created the object. Since the above example submits only one item in the tuple, then the index position of "NAME" within that tuple is 0 (remember that we start counting from 0 in Python). 
Here's another example where something more complex is done with the row values. This script finds the average population for counties in a dataset. To find the average, you need to divide the total population by the number of counties. The code below loops through each record and keeps a running total of the population and the number of records counted. Once all the records have been read, only one line of division is necessary to find the average. You can get the sample data for this script here.

?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
# Finds the average population in a counties dataset
import arcpy
 
featureClass = "C:\\Data\\Pennsylvania\\Counties.shp"
populationField = "POP1990"
nameField = "NAME"
 
average = 0
totalPopulation = 0
recordsCounted = 0
 
print("County populations:")
 
with arcpy.da.SearchCursor(featureClass, (nameField, populationField)) as countiesCursor:
    for row in countiesCursor:
        print (row[0] + ": " + str(row[1]))
        totalPopulation += row[1]
 
        recordsCounted += 1
 
average = totalPopulation / recordsCounted
 
print ("Average population for a county is " + str(average))
Differences between this example and the previous one:

The tuple includes multiple fields, with their names having been stored in variables near the top of the script.
The SearchCursor object goes by the variable name countiesCursor rather than cursor.
Before moving on, you should note that cursor objects have a couple of methods that you may find helpful in traversing their associated records.  To understand what these methods do, and to better understand cursors in general, it may help to visualize the attribute table with an arrow pointing at the "current row." When a cursor is first created, that arrow is pointing just above the first row in the table. When a cursor is included in a for loop, as in the above examples, each execution of the for statement moves the arrow down one row and assigns that row's values (a tuple) to the row variable.  If the for statement is executed when the arrow is pointing at the last row, there is not another row to advance to and the loop will terminate.  (The row variable will be left holding the last row's values.)

Imagine that you wanted to iterate through the rows of the cursor a second time.  If you were to modify the Cities example above, adding a second loop immediately after the first, you'd see that the second loop would never "get off the ground" because the cursor's internal pointer is still left pointing at the last row.  To deal with this problem, you could just re-create the cursor object.  However, a simpler solution would be to call on the cursor's reset() method.  For example:

cursor.reset()
This will cause the internal pointer (the arrow) to move just above the first row again, enabling you to loop through its rows again.

The other method supported by cursor objects is the next() method, which allows you to retrieve rows without using a for loop.  Returning to the internal pointer concept, a call to the next() method moves the pointer down one row and returns the row's values (again, as a tuple).  For example:

row = cursor.next()
An alternative means of iterating through all rows in a cursor is to use the next() method together with a while loop.  Here is the original Cities example modified to iterate using next() and while:

?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
# Prints the name of each city in a feature class (using next() and while)
 
import arcpy
 
featureClass = "C:\\Data\\USA\\USA.gdb\\Cities"
 
with arcpy.da.SearchCursor(featureClass,("NAME")) as cursor:
    try:
        row = cursor.next()
        while row:
            print (row[0])
            row = cursor.next()
    except StopIteration:
        pass
Points to note in this script:

This approach requires invoking next() both prior to the loop and within the loop.
Calling the next() method when the internal pointer is pointing at the last row will raise a StopIteration exception.  The example prevents that exception from displaying an ugly error.
You should find that using a for loop is usually the better approach, and in fact, you won't see the next() method even listed in the documentation of arcpy.da.SearchCursor.  We're pointing out the existence of this method because a) older ArcGIS versions have cursors that can/must be traversed in this way, so you may encounter this coding pattern if looking at older scripts, and b) you may want to use the next() method if you're in a situation where you know the cursor will contain exactly one row (or you're interested in only the first row).

In each of the cursor examples discussed thus far, the cursors retrieved all rows from the specified feature class.  Continue reading to see how to retrieve just a subset of rows meeting certain criteria




---
marp: true
size: 16:9 
paginate: true
#footer: Week 03.01
---

# GEOG 432/832: Programming, Scripting, and Automation for GIS

#

## Week 03.01: Geoprocessing in Python (with ArcGIS Pro too)

### Dr. Bitterman

#

--- 

# Today's schedule

- Open discussion
- Discussion and exercises

---

# Open discussion

---

# Unit schedule

- Today: Discussion and exercises
- Wednesday: Continuation and project introduction
- Friday: No class (reading day)

## Next week

- Next Monday: More, more, more
- Next Wednesday: Discussion of assigned reading (see Canvas)
- Next Friday: Lab 02 starts

---

# ArcPy

- The ArcPy package exposes ESRI ArcGIS Pro functions to Python env.
- Includes: 
    - modules
    - classes
    - functions
- Use all the geoprocessing tools in ArcGIS Pro in a Python script

---

# ArcPy and other editors

- It is possible to use the ArcGIS Pro python environment in other editors (e.g., Spyder, Python)
    - *(See your book and ESRI documentation for examples and tutorials)*
- It's a bit trickier with Jupyter/Anaconda - especially given the permissions restrictions in a university lab... :(    
- For this work, we're going to use the built-in Jupyter notebook functionality in ArcGIS Pro

---
# Download the in-class data

- Start a new ArcGIS Pro project
- Download ```week03inclass.zip``` from Canvas
- Extract it to the same folder as your project

---

# Importing ArcPy

Working with ArcPy starts with importing the package. A typical geoprocessing script therefore starts with the following line of code:
import arcpy
Once you import ArcPy, you can run all the geoprocessing tools found in the toolboxes installed with ArcGIS Pro.
ArcPy contains several modules, including a module for working with data (arcpy.da), a map scripting module (arcpy.mp), a module for image analysis and interpretation (arcpy.ia), and a module for map algebra and raster analysis (arcpy.sa). Once you import ArcPy, you can start using its modules, functions, and classes.
Importing ArcPy in your script not only exposes the functionality of ArcPy, it also performs two important checks: availability of ArcPy and availability of a license. First, it determines whether ArcPy is, in fact, available, which requires that ArcPy is installed and that the Python editor used to run the script is configured to use ArcPy. ArcPy is installed as part of the installation of ArcGIS Pro, and the ArcPy package is part of the default arcgispro-py3 environment. Therefore, if you have ArcGIS Pro installed on your computer, you also have ArcPy. When you are using IDLE to write your code, and if you are using the version of IDLE installed as part of the ArcGIS Pro installation, ArcPy is available. The default installation of other IDEs—for example, PyCharm—requires some additional steps for ArcPy to be available. If ArcPy is not available, the line of code import arcpy will generate the following error message:
ImportError: No module named arcpy
When ArcPy is available, the second check is whether a license is available. It is important to recognize that ArcPy is part of ArcGIS Pro and therefore requires licensing. Python itself is open-source software, as are many other packages for Python. This means the software can be distributed freely. ArcPy, on the other hand, is not open source, and as a result it is necessary to check that a license is available. If ArcPy is installed, but no license is available, the line of code import arcpy will generate the following error message:
RuntimeError: NotInitialized
When writing code in the Python window in ArcGIS Pro, there is no need to import ArcPy or check for licensing. Because you are running code from within the ArcGIS Pro application, the availability and licensing of ArcPy is implicit. Any Python script that runs outside ArcGIS Pro—for example, using IDLE or PyCharm—must use import arcpy.

---

# Data storage

## Discussion question:

*How do we store spatial data? What are you familiar with?*

---

# Geodatabases

Over the years, Esri has developed various ways of storing spatial data. They encourage you to put your data in geodatabases, which are organizational structures for storing datasets and defining relationships between those datasets. Different flavors of geodatabase are offered for storing different magnitudes of data.

File geodatabases are a way of storing data on the local file system in a proprietary format developed by Esri. They offer more functionality than shapefiles and are best suited for personal use or small organizations.
ArcSDE geodatabases or "enterprise geodatabases" store data on a central server in a relational database management system (RDBMS) such as SQL Server, Oracle, or PostgreSQL. These are large databases designed for serving data not just to one computer, but to an entire enterprise. Since working with an RDBMS can be a job in itself, Esri has develped ArcSDE as "middleware" that allows you to configure and read your datasets in ArcGIS Pro and other Esri products without touching the RDBMS software.

ArcGIS Pro also provides the ability to pull data directly out of an RDBMS using SQL queries, with no ArcSDE involved, through query layers.
A single vector dataset within a geodatabase is called a feature class. Feature classes can be optionally organized in feature datasets. Raster datasets can also be stored in geodatabases.

---

# Shapefiles

Although geodatabases are essential for long-term data storage and organization, it's sometimes convenient to access datasets in a "standalone" format on the local file system. Esri's shapefile is probably the most ubiquitous standalone vector data format (it even has its own Wikipedia article). A shapefile actually consists of several files that work together to store vector geometries and attributes. The files all have the same root name, but use different extensions. You can zip the participating files together and easily email them or post them in a folder for download. In the Esri file browsers in ArcGIS Pro, the shapefiles just appear as one file.

Note:
You may see that in Esri's documentation, shapefiles are also referred to as "feature classes."  When you see the term "feature class," consider it to mean a vector dataset that can be used in ArcGIS.
Another type of standalone dataset dating back to the early days of ArcGIS is the ArcInfo coverage. Like the shapefile, the coverage consists of several files that work together. Coverages are definitely an endangered species, but you might encounter them if your organization used ArcInfo Workstation in the past.

Raster datasets are also often stored in standalone format instead of being loaded into a geodatabase. A raster dataset can be a single file, such as a JPEG or a TIFF, or, like a shapefile, it can consist of multiple files that work together.

---

# GDBs vs. shapefiles

---

# Paths

code block and try it!

---

# Workspaces

PSU + Book

---

# Reading data

PSU

---

# Accessing fields

PSU

---

# Tools and parameters

---

# Using tools - comparing buffer and clip

---

# Using variables to represent files

---

# Results



# Workspaces

Typically one of the first tasks in a script is to set the current workspace. A workspace provides a default location for the files you will be working with, such as inputs and outputs of geoprocessing tools. For example, here is how to set the current workspace to C:\Data:
import arcpy
arcpy.env.workspace = "C:/Data"
Note: Remember that you should not use a backward slash (\) for paths because Python views it as an escape character. Other correct notations are r"C:\Data" and "C:\\Data".
Notice that the path is a string variable.
A stand-alone Python script also has a current working directory, which by default is the location of the script. You can obtain the current working directory using os.getcwd(), and you can change it using os.chdir(). However, these options are not enough to work with geospatial datasets because not all valid workspaces in ArcGIS Pro are recognized by the Windows operating system. As a result, the workspace in a geoprocessing script should be set using arcpy.env.workspace.
A workspace is one of several environments, which are exposed as properties of ArcPy’s env class. Section 5.9 explains classes in more detail. These properties retrieve the current values or set them. In the preceding code, env is a class, and workspace is a property of this class. When using classes in ArcPy, the syntax is
arcpy.<class>.<property>
You will see more examples of this syntax later in this chapter.
One alternative approach is to import only the env class. You can use the from import statement to import only a portion of a module or package. The following code imports just the env class. Once the class is imported, instead of accessing environment properties using arcpy .env, you can simplify it to env.
from arcpy import env
env.workspace = "C:/Data"
Although this approach is common, it does not save much typing. As a result, it is recommended to use arcpy.env.workspace instead of from arcpy import env followed by env.workspace.
You can further control the import by giving a module or part of a module a custom name using the from import as statement as follows:
from arcpy import env as myenv
myenv.workspace = "C:/Data"
Although using custom names does not shorten the length of your code, it can make it easier to read.
The from import as * statement goes a step further. In this case, the contents of the module are imported directly into the namespace, meaning that you no longer need to add a prefix to the contents or use the module name.
from arcpy import env as *
workspace = "C:/Data"
A namespace in Python is a system to make sure all the names are unique and can be used without any conflicts. In simple terms, a namespace is a collection of names used in a script. When you use from <module> import * or from <module> import <class> as *, you are importing all the names directly into the current namespace.
Note: The use of these alternative import statements can reduce the length of your code, but you must be careful because other objects, variables, and modules that have the same name will be overwritten. In general, it is recommended that you stick with arcpy.env.workspace. An exception is the use of map algebra operations using the arcpy.sa module; chapter 10 explains this exception.

---

# Tools and parameters

ArcPy gives you access to all the geoprocessing tools in ArcGIS Pro. In Python, geoprocessing tools are referred to by name. This name does not correspond exactly to the tool label, which is how the tool appears in ArcGIS Pro. A tool name is generally the same as the tool label but contains no spaces. For example, the name of the Add Field tool in the Data Management toolbox is AddField in ArcPy.
In addition to using the tool name, a reference to a tool also requires the toolbox alias. This is because multiple tools in different toolboxes can share the same name. For example, there are multiple Clip tools: one in the Analysis toolbox (i.e., Clip) and one in the Data Management toolbox (i.e., Clip Raster, but the name in ArcPy is Clip). The toolbox alias is not the same as either the name or the label of the toolbox—it is typically an abbreviated version. For example, the alias of the Data Management toolbox is “management.”
The Clip tool in the Analysis toolbox is referenced as Clip_analysis(). The name of the toolset (i.e., Extract in this case) is not referenced. On the other hand, the Clip Raster tool in the Data Management toolbox is referenced as Clip_management().
There are two ways to access a tool in a line of Python code. The easiest way to use a tool is to call its corresponding function. All geoprocessing tools are available as functions in ArcPy. A function in Python is a defined bit of functionality that does a specific task; therefore it makes sense for each geoprocessing tool in ArcGIS Pro to be a function in ArcPy. The syntax for calling a tool by its function is
arcpy.<toolname_toolboxalias>(<parameters>)
For example, the following code runs the Clip tool:
import arcpy
arcpy.env.workspace = "C:/Data"
arcpy.Clip_analysis("streams.shp", "study.shp", "result.shp")
Tools are also available by using modules that match the toolbox alias name. An alternative way to access a tool is to first call the toolbox as a module, and then the tool as a function of this module, followed by the tool’s parameters. The syntax is
arcpy.<toolboxalias>.<toolname>(<parameters>)
Here is what the example looks like for running the Clip tool:
import arcpy
arcpy.env.workspace = "C:/Data"
arcpy.analysis.Clip("streams.shp", "study.shp", "result.shp")
Both methods are correct; the approach you use is a matter of preference and coding habits.
Note: The coding style adopted for this book mostly uses the arcpy.Clip_analysis style of calling tools, but you may see the other style in example scripts from other sources.
Just a few quick reminders regarding Python syntax:
Python is case sensitive, so Clip is correct, but clip is not. When you use clip_analysis, you will get an error message because the function cannot be found: AttributeError: module 'arcpy' has no attribute 'clip_analysis'.
The use of spaces, or whitespace, in a line of code has no effect on its execution. For example, workspace="C:/Data" is the same as workspace = "C:/Data". Whitespace is recommended to improve readability but is not required. However, do not include spaces between modules, functions, classes, methods, and properties. For example, env.workspace is correct, but env. workspace (with a space in between) is not. Also, do not include spaces between functions and their arguments, so <toolname>(<parameters>) is correct, but <toolname> (<parameters>) is not.
Note: The use of extra spaces does not always result in an error, and Python is relatively robust. For example, using env. workspace (with a space in between) does not produce an error, nor does arcpy .analysis. Clip(). In general, however, it is good practice not to add any extra spaces.
Quotation marks in Python are always straight and not curly, so use " " and not “ ”. For code typed in a Python editor, the correct style of quotation marks is entered automatically. However, incorrect quotation marks can occur when copying code from other applications, such as a Microsoft Word document or a PDF file.
A key aspect of running geoprocessing tools is to get the syntax right for the parameters. Every geoprocessing tool has parameters, including required and optional ones, that provide the tool with the information it needs for execution. Common parameters are input datasets, output datasets, and keywords that control the execution of the tool. Parameters themselves have properties, such as the following:
Name: a unique name for each tool parameter
Type: the type of data expected, such as feature class, integer, string, or raster
Direction: whether the parameter defines input or output values
Required: whether a value must be provided for a parameter or is optional
The documentation of each tool in ArcGIS Pro helps describe its parameters and properties. Once a valid set of parameters is provided, the tool is ready to run. Most parameters are specified as a string. Strings consist of text that identifies a parameter value, such as a path to a dataset or a keyword.
The Clip tool’s documentation, part of which is shown in the figure, describes its parameters.

--- 

# Comparing tools (buffer vs. clip)

The Clip tool has four parameters, with the last one (cluster_tolerance) being optional. The syntax of the Clip tool is
Clip(in_features, clip_features, out_feature_class,
     {cluster_tolerance})
The name of the Clip tool is followed by the tool’s parameters in parentheses. Parameters are separated by a comma. Optional parameters are surrounded by braces { }. A single space is used between the parameters, but it is only to improve legibility and is not required.
The syntax of geoprocessing tools typically follows the same general pattern, as follows:
Required parameters come first, followed by optional parameters. This order reflects the general design of the tools in the geoprocessing framework in ArcGIS Pro.
The input datasets are usually the first parameter or parameters, followed by the output dataset(s) if there is one. Next are additional required parameters and, finally, optional parameters. This order is not always followed exactly, especially for tools with many parameters.
Parameter names for input datasets are prefixed by “in_” (such as in_data, in_features, in_table, in_workspace), and parameter names for output datasets are prefixed by “out_” (such as, out_data, out_features, out_table).
Listing required parameters first makes it easy to simply leave out the optional parameters when they are not needed. Sometimes, however, some of the optional parameters must be set. Because parameters must be specified in the order that they are listed in the tool syntax, it can mean that some optional parameters may need to be skipped.
Consider, for example, the syntax of the Buffer tool:
Buffer(in_features, out_feature_class, 
       buffer_distance_or_field, {line_side}, 
       {line_end_type}, {dissolve_option}, {dissolve_field})
A code example of the Buffer tool is as follows:
import arcpy
arcpy.env.workspace = "C:/Data/study.gdb"
arcpy.Buffer_analysis("roads", "buffer", "100 METERS")
Using this example, how would you specify the optional dissolve_option parameter and skip the other optional parameters that follow the required parameters? Specifying this parameter can be accomplished in different ways, as follows:
By setting the optional parameters using an empty string (""), the number sign ("#"), or the value None
By specifying by name the parameter that must be set, bypassing all others
The Buffer tool has three required parameters and five optional parameters. To specify a dissolve option (e.g., LIST) and the field to use in this dissolve (e.g., CODE), two optional parameters must be skipped. This can be done in several ways:
arcpy.Buffer_analysis("roads", "buffer", "100 METERS", "", "", 
                      "LIST", "CODE")
arcpy.Buffer_analysis("roads", "buffer", "100 METERS", "#", "#", 
                      "LIST", "CODE")
arcpy.Buffer_analysis("roads", "buffer", "100 METERS", None, None, 
                      "LIST", "CODE")
arcpy.Buffer_analysis("roads", "buffer", "100 METERS", 
                      dissolve_option="LIST", dissolve_field="CODE")
In each of these four cases, the optional parameters line_side and line_end_type are left to their default values.
Note: Although each of these three options is correct, the examples in this book typically use the empty string option (""). Also note that when a parameter is specified by name, by convention no space is used—i.e., dissolve_option="LIST" and not dissolve_option = "LIST" although this style is not required.
The use of None warrants a brief discussion. None is a Python keyword and is used to define a null value or no value at all. It is not the same as an empty string, but it has the same effect in the context of setting parameters for a tool. None is its own data type in Python—i.e., NoneType. This keyword is capitalized, and therefore the use of none is incorrect and would produce an error. It is also not the same as using a string with the same characters, and the use of "none", "None", or "NONE" would also produce an error. These similar words can lead to confusion, because some parameter values of geoprocessing tools use NONE as one of the options. So, for a different scenario, the value of a parameter could be set as <parameter_name>="NONE". In this example, NONE is a string and not the same as the Python keyword None. Therefore, when you see "NONE" in a code example of tool documentation, the parameter is set to this string, which has a specific meaning for that tool. It does not mean the parameter is set to a null value.

---

# Using variables to represent feature classes

In the examples so far, the parameters of the tool use the actual file name (for example, roads). Thus, the file names are hard-coded. That is, the parameters are not set as variables, but use the values directly. Although this syntax is correct and works fine, it is often more useful to make your code flexible by using variables for parameters instead of using hard-coded values. First, you must create variables and assign them a value. Then you can use the variables for the parameters. These variables are passed to the tool when the function is called. For example, in the case of the Clip tool, it would look like the following:
import arcpy
arcpy.env.workspace = "C:/Data"
infc = "streams.shp"
clipfc = "study.shp"
outfc = "result.shp"
arcpy.Clip_analysis(infc, clipfc, outfc)


Note that the variables do not need to have the same names as the parameters in the tool’s syntax. For example, in the syntax of the Clip tool, the name of the parameter for the input features is in_features, whereas the script uses infc as the variable. You can essentially use any valid variable name, but it is good practice to give your variables meaningful names.
In this example script, the names of the datasets are still hard-coded in the script itself but not in the specific line of code that calls the Clip tool. The next logical step is to have the values of the variables provided by a user or another script or tool, which means the file names no longer appear in the script. For example, the following code runs the Copy tool, and the input and output feature classes are obtained from user input using the arcpy.GetParameterAsText() function:
import arcpy
infc = arcpy.GetParameterAsText(0)
outfc = arcpy.GetParameterAsText(1)
arcpy.Copy_management(infc, outfc)
Setting tool parameters on the basis of user input is commonly used for script tools. Working with variables in this way gives you more flexibility and makes much of your code reusable.
Note: When you start writing geoprocessing scripts, it is fine to use hard coding for tool parameters. However, the use of variables is strongly encouraged. Ultimately, you are working toward developing scripts and tools that can be shared with others, and those tools typically require the use of variables. In addition, variables make it easier to reuse portions of your code.
Here are a few quick reminders regarding variable names in Python. Variable names can consist of any combination of valid characters. However, adopting a consistent coding style is recommended. For example, the Style Guide for Python Code recommends using all lowercase characters, and using underscores (_) only if it improves readability—for example, my_clip or clip_result. Variable names also should be kept short (but meaningful) to limit the need for typing and associated typos—for example, clipfc instead of clipfeatureclass.

---

# The results of tools

5.6 Working with Result objects

ArcPy returns the output of a tool as a Result object. When the output of a tool is a new or updated feature class, the Result object includes the path to the dataset. For other tools, however, the Result object can consist of a string, a number, or a Boolean value. One of the advantages of Result objects is that you can keep track of information about the running of tools. This includes not only the output, but also messages and parameters.
For example, in the following code, a geoprocessing tool is run, and the output is returned as a Result object:
import arcpy
arcpy.env.workspace = "C:/Data"
mycount = arcpy.GetCount_management("streams.shp")
print(mycount)
This code displays the string representation of the Result object—for example:
3153
When the output of a tool consists of a feature class, the Result object includes the path to the dataset. For example, the following code runs the Clip tool:
import arcpy
arcpy.env.workspace = "C:/Data"
myresult = arcpy.Clip_analysis("streams.shp", "study.shp", 
                               "result.shp")
print(myresult)
Running the code displays the string representation of the path to the output dataset:
C:/Data/result.shp
The Result object can be used as an input to another function. For example, in the following code, a feature class is buffered using the Buffer tool. The output polygon feature class is returned as an object, and the object is used as the input to the Get Count tool, as follows:
import arcpy
arcpy.env.workspace = "C:/Data/study.gdb"
buffer = arcpy.Buffer_analysis("str", "str_buf", "100 METERS")
count = arcpy.GetCount_management(buffer)
print(count)
You can probably see where this is going. You can create a series of geoprocessing operations, the same as in ModelBuilder, and only the final desired output is returned to the application that called the script.
The Result object also has properties and methods, as illustrated next, whereas section 5.12 covers methods related to messages.
Although many tools have only a single output, some tools have multiple outputs. The getOutput() method of the Result object can obtain a specific output by using an index number, as follows:
count = arcpy.GetCount_management(buffer).getOutput(0)
The outputs are also indexed, so you can also use an index number directly to obtain a specific result:
count = arcpy.GetCount_management(buffer)[0]
Note: For tools that have only a single output, including the Get Count tool, there is no need to use getOutput() or an index number.


# Functions

A function in Python performs a specific task. Nearly all geoprocessing tools in ArcGIS Pro are provided as functions in ArcPy. In addition, ArcPy provides several functions that are not tools. Functions can list datasets, retrieve properties of a dataset, check for the existence of data, validate names of datasets, and perform many other useful tasks. These functions are designed for Python workflows, and therefore are available only in ArcPy and not as tools in ArcGIS Pro. These functions are sometimes referred to as nontool functions. To summarize, nearly all geoprocessing tools in ArcGIS Pro are functions in ArcPy, but not all ArcPy functions are geoprocessing tools in ArcGIS Pro.
The general form of a function is like that of a tool. A function has parameters (also referred to as arguments), which can be required or optional. A function returns values. These values can be a path to a dataset, a string, a number, a Boolean value, or a geoprocessing object.
The syntax of a function in ArcPy is the same as for tools:
arcpy.<functionname>(<arguments>)
For example, the following code determines whether a dataset exists, and then prints either True or False:
import arcpy
print(arcpy.Exists("C:/Data.streams.shp"))
The arcpy.Exists() function returns a Boolean value. Other functions return other types of values, including strings and numbers.
There are many ArcPy functions, which can be divided into the following categories:
ArcGIS Online/Portal
Cursors
Data store
Describing data
Environments and settings
Fields
General
General data functions
Geodatabase administration
Geometry
Getting and setting parameters
Licensing and installation
Listing data
Log history
Messaging and error handling
Progress dialog box
Publishing
Raster
Spatial references and transformations
Tools and toolboxes
These categories are created primarily to provide a logical organization of the functions, but the names of these categories do not appear in Python syntax. Unlike tools, these functions are always called directly, without reference to the category. ArcGIS Pro helps provide a complete list of ArcPy functions and a detailed description of each. Later chapters revisit several of these functions.
Technically speaking, nearly all geoprocessing tools are functions in ArcPy, and they are accessed like any other Python function. To avoid confusion, ArcPy functions are divided into tool functions and nontool functions. There are several important distinctions between the two:
The documentation is in different sections of ArcGIS Pro help. Tools are documented under Tool Reference. The documentation also can be obtained from the tool dialog box when running a tool in ArcGIS Pro. Nontool functions are documented only in the ArcPy documentation under the Python tab of the ArcGIS Pro help pages.
Tools are licensed by license level (Basic, Standard, and Advanced) and by extension (3D Analyst, Network Analyst, Spatial Analyst, and more). The Tool Reference indicates the license level that is required for each tool. Nontool functions, on the other hand, are not licensed separately. All ArcPy nontool functions are available to use with ArcPy, independent of the license level.
Tools produce geoprocessing messages, which can be accessed through a variety of functions. Nontool functions do not produce these messages.
Calling tools requires the use of the toolbox alias or the module name, whereas nontool functions do not.
Later chapters explore many of these nontool functions.